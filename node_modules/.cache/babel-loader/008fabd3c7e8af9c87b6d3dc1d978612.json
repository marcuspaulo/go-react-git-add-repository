{"ast":null,"code":"'use strict';\n\nvar reduxSaga_utils = require('redux-saga/utils');\n\nvar ramdasauce = require('ramdasauce');\n\nvar ramda = require('ramda'); // effect names\n\n\nvar TAKE = 'TAKE';\nvar PUT = 'PUT';\nvar CALL = 'CALL';\nvar CPS = 'CPS';\nvar FORK = 'FORK';\nvar JOIN = 'JOIN';\nvar RACE = 'RACE';\nvar CANCEL = 'CANCEL';\nvar SELECT = 'SELECT';\nvar PARALLEL = 'PARALLEL';\nvar ITERATOR = 'ITERATOR';\nvar PROMISE = 'PROMISE'; // not from redux-saga\n\nvar UNKNOWN = 'UNKNOWN'; // not from redux-saga\n// monitoring statuses\n\nvar PENDING = 'PENDING';\nvar RESOLVED = 'RESOLVED';\nvar REJECTED = 'REJECTED';\nvar CANCELLED = 'CANCELLED';\n\nvar getEffectName = function getEffectName(effect) {\n  if (!effect) return UNKNOWN;\n  if (effect instanceof Promise) return PROMISE;\n  if (reduxSaga_utils.asEffect.take(effect)) return TAKE;\n  if (reduxSaga_utils.asEffect.put(effect)) return PUT;\n  if (reduxSaga_utils.asEffect.call(effect)) return CALL;\n  if (reduxSaga_utils.asEffect.cps(effect)) return CPS;\n  if (reduxSaga_utils.asEffect.fork(effect)) return FORK;\n  if (reduxSaga_utils.asEffect.join(effect)) return JOIN;\n  if (reduxSaga_utils.asEffect.race(effect)) return RACE;\n  if (reduxSaga_utils.asEffect.cancel(effect)) return CANCEL;\n  if (reduxSaga_utils.asEffect.select(effect)) return SELECT;\n  if (reduxSaga_utils.is.array(effect)) return PARALLEL;\n  if (reduxSaga_utils.is.iterator(effect)) return ITERATOR;\n  return UNKNOWN;\n}; // Provides an additional description of the effect.  A friendlier name\n// to display to the humans.\n\n/* eslint-disable no-cond-assign */\n\n\nvar getEffectDescription = function getEffectDescription(effect) {\n  if (!effect) return UNKNOWN;\n\n  if (effect instanceof Promise) {\n    var display = void 0;\n\n    if (effect.name) {\n      // a promise object with a manually set name prop for display reasons\n      display = PROMISE + '(' + effect.name + ')';\n    } else if (effect.constructor instanceof Promise.constructor) {\n      // an anonymous promise\n      display = PROMISE;\n    } else {\n      // class which extends Promise, so output the name of the class to precise\n      display = PROMISE + '(' + effect.constructor.name + ')';\n    }\n\n    return display;\n  }\n\n  if (effect.root) return effect.saga.name;\n  var data = void 0;\n  if (data = reduxSaga_utils.asEffect.take(effect)) return data.pattern || 'channel';\n  if (data = reduxSaga_utils.asEffect.put(effect)) return data.channel ? data.action : data.action.type;\n\n  if (data = reduxSaga_utils.asEffect.call(effect)) {\n    return ramdasauce.isNilOrEmpty(data.fn.name) ? '(anonymous)' : data.fn.name;\n  }\n\n  if (data = reduxSaga_utils.asEffect.cps(effect)) return data.fn.name;\n  if (data = reduxSaga_utils.asEffect.fork(effect)) return data.fn.name;\n  if (data = reduxSaga_utils.asEffect.join(effect)) return data.name;\n  if (reduxSaga_utils.asEffect.race(effect)) return null;\n  if (data = reduxSaga_utils.asEffect.cancel(effect)) return data.name;\n  if (data = reduxSaga_utils.asEffect.select(effect)) return data.selector.name;\n  if (reduxSaga_utils.is.array(effect)) return null;\n  if (reduxSaga_utils.is.iterator(effect)) return effect.name;\n  return UNKNOWN;\n}; // import { reject, values, pluck, isNil, split, pathOr, last, forEach, propEq, filter, __, map, omit } from 'ramda'\n// creates a saga monitor\n\n\nvar _createSagaMonitor = function _createSagaMonitor(reactotron, options) {\n  var pluginConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // a lookup table of effects - keys are numbers, values are objects\n\n  var effects = {};\n  var exceptions = pluginConfig.except || []; // filtering that effect table\n\n  var byParentId = ramda.propEq('parentEffectId', ramda.__);\n  var byLabel = ramda.propEq('label', ramda.__);\n\n  var getChildEffectInfos = function getChildEffectInfos(parentEffectId) {\n    return ramda.filter(byParentId(parentEffectId), ramda.values(effects));\n  };\n\n  var getChildEffectIds = function getChildEffectIds(effectId) {\n    return ramda.pluck('effectId', getChildEffectInfos(effectId));\n  }; // start a relative timer\n\n\n  var timer = reactotron.startTimer(); // ---------------- Sending Effect Updates ----------------\n  // const sendReactotronEffectTree = () => reactotron.send('saga.effect.update', effects)\n  // ---------------- Starting -----------------------------\n  // redux-saga calls this when an effect is triggered (started)\n\n  var effectTriggered = function effectTriggered(description) {\n    var effect = description.effect,\n        effectId = description.effectId,\n        parentEffectId = description.parentEffectId,\n        label = description.label; // create an EffectInfo to hold the details\n\n    var effectInfo = {\n      effectId: effectId,\n      parentEffectId: parentEffectId,\n      effect: effect,\n      label: label,\n      status: PENDING,\n      name: getEffectName(effect),\n      description: getEffectDescription(effect),\n      result: null,\n      startedAt: timer()\n    }; // store it\n\n    effects[effectId] = effectInfo; // send it\n    // sendReactotronEffectTree()\n  }; // ---------------- Finishing ----------------------------\n  // update the duration of the effect\n\n\n  var updateDuration = function updateDuration(effectInfo) {\n    effectInfo.duration = timer() - effectInfo.startedAt;\n  }; // fires when a task has been resolved\n\n\n  var taskResolved = function taskResolved(effectId, taskResult) {\n    // lookup this effect info\n    var effectInfo = effects[effectId];\n    updateDuration(effectInfo);\n    var duration = effectInfo.duration; // grab the parent too\n\n    var parentEffectId = effectInfo.parentEffectId;\n    var parentEffectInfo = effects[parentEffectId];\n    var children = []; // a human friendly name of the saga task\n\n    var sagaDescription = void 0; // what caused the trigger\n\n    var triggerType = void 0; // for FORK tasks, we have a bunch on things to pass along\n\n    if (effectInfo.name === FORK) {\n      var args = ramda.pathOr([], ramda.split('.', 'effect.FORK.args'), effectInfo);\n      var lastArg = ramda.last(args);\n      triggerType = lastArg && lastArg.type;\n\n      if (parentEffectInfo) {\n        if (parentEffectInfo.name === ITERATOR) {\n          sagaDescription = parentEffectInfo.description;\n        }\n      } else {\n        sagaDescription = '(root)';\n        triggerType = effectInfo.description + '()';\n      } // flatten out the nested effects\n\n\n      var buildChild = function buildChild(depth, effectId) {\n        var sourceEffectInfo = effects[effectId];\n        if (ramda.isNil(sourceEffectInfo)) return;\n        var extra = null;\n\n        if (sourceEffectInfo.effect) {\n          switch (sourceEffectInfo.name) {\n            case CALL:\n              extra = sourceEffectInfo.effect[sourceEffectInfo.name].args;\n              break;\n\n            case PUT:\n              extra = sourceEffectInfo.effect[sourceEffectInfo.name].action;\n              break;\n            // children handle this\n\n            case RACE:\n              break;\n            // TODO: More of customizations needed here\n\n            default:\n              extra = sourceEffectInfo.effect[sourceEffectInfo.name];\n              break;\n          }\n        } // assemble the structure\n\n\n        children.push({\n          depth: depth,\n          effectId: sourceEffectInfo.effectId,\n          parentEffectId: sourceEffectInfo.parentEffectId || null,\n          name: sourceEffectInfo.name || null,\n          description: sourceEffectInfo.description || null,\n          duration: Math.round(sourceEffectInfo.duration),\n          status: sourceEffectInfo.status || null,\n          winner: sourceEffectInfo.winner || null,\n          loser: sourceEffectInfo.loser || null,\n          result: sourceEffectInfo.result || null,\n          extra: extra || null\n        }); // rerun this function for our children\n\n        ramda.forEach(function (x) {\n          return buildChild(depth + 1, x);\n        }, getChildEffectIds(effectId));\n      };\n\n      var xs = getChildEffectIds(effectId);\n      ramda.forEach(function (effectId) {\n        return buildChild(0, effectId);\n      }, xs);\n    } // saga not blacklisted?\n\n\n    if (!ramda.contains(effectInfo.description, exceptions)) {\n      reactotron.send('saga.task.complete', {\n        triggerType: triggerType || effectInfo.description,\n        description: sagaDescription,\n        duration: Math.round(duration),\n        children: children\n      });\n    } // effects = omit(map(String, pluck('effectId', children)), effects)\n\n  }; // redux-saga calls this when an effect is resolved (successfully or not)\n\n\n  var effectResolved = function effectResolved(effectId, result) {\n    // lookup this effect info and set the rsult\n    var effectInfo = effects[effectId];\n    updateDuration(effectInfo);\n    effectInfo.result = result; // this is a task\n\n    if (reduxSaga_utils.is.task(result)) {\n      // when the task promise resolves,\n      var onTaskResult = function onTaskResult(taskResult) {\n        if (result.isCancelled()) {\n          effectCancelled(effectId);\n        } else {\n          effectResolved(effectId, taskResult);\n          taskResolved(effectId, taskResult);\n        }\n      }; // hook the promise to capture the resolve or reject\n\n\n      var promise = result.done ? result.done : result.toPromise();\n      promise.then(onTaskResult, function (error) {\n        effectRejected(effectId, error);\n\n        if (!error.reactotronWasHere) {\n          reactotron.reportError(error);\n        }\n\n        error.reactotronWasHere = true;\n      });\n    } else {\n      // this is an effect and we are complete\n      effectInfo.status = RESOLVED;\n      effectInfo.result = result;\n\n      if (effectInfo.name === RACE) {\n        setRaceWinner(effectId, result);\n      }\n    } // send it\n    // sendReactotronEffectTree()\n\n  }; // flags on of the children as the winner\n\n\n  var setRaceWinner = function setRaceWinner(effectId, resultOrError) {\n    var winnerLabel = Object.keys(resultOrError)[0];\n    var children = getChildEffectInfos(effectId);\n    var winningChildren = ramda.filter(byLabel(winnerLabel), children);\n    var losingChildren = ramda.reject(byLabel(winnerLabel), children);\n\n    var setWinner = function setWinner(effectInfo) {\n      effectInfo.winner = true;\n    };\n\n    var setLoser = function setLoser(effectInfo) {\n      effectInfo.loser = true;\n    }; // set the 1 (hopefully 1) winner -- but i'm not sure\n\n\n    ramda.forEach(setWinner, winningChildren);\n    ramda.forEach(setLoser, losingChildren);\n  }; // ---------------- Failing ------------------------------\n  // redux-saga calls this when an effect is rejected (an error has happened)\n\n\n  var effectRejected = function effectRejected(effectId, error) {\n    var effectInfo = effects[effectId];\n    updateDuration(effectInfo);\n    effectInfo.status = REJECTED;\n    effectInfo.error = error;\n\n    if (effectInfo.name === RACE) {\n      setRaceWinner(effectId, error);\n    } // send it\n    // sendReactotronEffectTree()\n\n  }; // ---------------- Cancelling ---------------------------\n  // redux-saga calls this when an effect is cancelled\n\n\n  var effectCancelled = function effectCancelled(effectId) {\n    var effectInfo = effects[effectId];\n    updateDuration(effectInfo);\n    effectInfo.status = CANCELLED; // send it\n    // sendReactotronEffectTree()\n  }; // the interface for becoming a redux-saga monitor\n\n\n  return {\n    effectTriggered: effectTriggered,\n    effectResolved: effectResolved,\n    effectRejected: effectRejected,\n    effectCancelled: effectCancelled,\n    actionDispatched: function actionDispatched() {}\n  };\n}; // Behold!  The entry point of our plugin\n\n\nvar plugin$1 = function plugin$1(pluginConfig) {\n  return function (reactotron) {\n    return {\n      // make these functions available on the Reactotron\n      features: {\n        // spawn a saga monitor with the given options\n        createSagaMonitor: function createSagaMonitor(options) {\n          return _createSagaMonitor(reactotron, options, pluginConfig);\n        }\n      }\n    };\n  };\n};\n\nmodule.exports = plugin$1;","map":null,"metadata":{},"sourceType":"script"}